import ipaddress
import json
import os
import random
import re

# Fun fact: All functions below have been generated by GitHub Copilot
# Thanks a lot, Copilot!

# Helper functions

# Return a list of env vars in a string, supports both $NAMÂ§ and ${NAME} format for the env var
# This can potentially be used to get around permissions, so this check is critical for security
# Please report any security vulnerabilities you find in this check to aaron.dewes@web.de


def getEnvVars(string: str):
    string = str(string)
    envVars = re.findall(r'\$\{.*?\}', string)
    newEnvVars = re.findall(r"\$(?!{)([A-z1-9]+)", string)
    return [envVar[2:-1] for envVar in envVars] + newEnvVars


# Check if an array only contains values which are also in another array
def checkArrayContainsAllElements(array: list, otherArray: list):
    for element in array:
        if element not in otherArray:
            return False
    return True

# Combines two objects
# If the key exists in both objects, the value of the second object is used
# If the key does not exist in the first object, the value from the second object is used
# If a key contains a list, the second object's list is appended to the first object's list
# If a key contains another object, these objects are combined


def combineObjects(obj1: dict, obj2: dict):
    for key in obj2:
        if key in obj1:
            if isinstance(obj1[key], list):
                obj1[key] = obj1[key] + obj2[key]
            elif isinstance(obj1[key], dict):
                obj1[key] = combineObjects(obj1[key], obj2[key])
            else:
                obj1[key] = obj2[key]
        else:
            obj1[key] = obj2[key]
    return obj1


# Vars which are always allowed without permissions
always_allowed_env = ["TOR_PROXY_IP", "TOR_PROXY_PORT",
                      "APP_DOMAIN", "APP_HIDDEN_SERVICE", "BITCOIN_NETWORK"]

# Main functions


def permissions():
    return {
        "lnd": {
            "environment_allow": {
                "LND_IP": "${LND_IP}",
                "LND_GRPC_PORT": "${LND_GRPC_PORT}",
                "LND_REST_PORT": "${LND_REST_PORT}",
                "BITCOIN_NETWORK": "${BITCOIN_NETWORK}"
            },
            "volumes": [
                '${LND_DATA_DIR}:/lnd:ro'
            ]
        },
        "bitcoind": {
            "environment_allow": {
                "BITCOIN_IP":                 "${BITCOIN_IP}",
                "BITCOIN_NETWORK":            "${BITCOIN_NETWORK}",
                "BITCOIN_P2P_PORT":           "${BITCOIN_P2P_PORT}",
                "BITCOIN_RPC_PORT":           "${BITCOIN_RPC_PORT}",
                "BITCOIN_RPC_USER":           "${BITCOIN_RPC_USER}",
                "BITCOIN_RPC_PASS":           "${BITCOIN_RPC_PASS}",
                "BITCOIN_RPC_AUTH":           "${BITCOIN_RPC_AUTH}",
                "BITCOIN_ZMQ_RAWBLOCK_PORT":  "${BITCOIN_ZMQ_RAWBLOCK_PORT}",
                "BITCOIN_ZMQ_RAWTX_PORT":     "${BITCOIN_ZMQ_RAWTX_PORT}",
                "BITCOIN_ZMQ_HASHBLOCK_PORT": "${BITCOIN_ZMQ_HASHBLOCK_PORT}",
            }
        },
        "electrum": {
            "environment_allow": {
                "ELECTRUM_IP": "${ELECTRUM_IP}",
                "ELECTRUM_PORT": "${ELECTRUM_PORT}",
            }
        }
    }


def convertContainerPermissions(app):
    for container in app['containers']:
        if 'permissions' in container:
            for permission in container['permissions']:
                if(permission in permissions()):
                    container = combineObjects(
                        container, permissions()[permission])
            del container['permissions']
    return app


def convertContainersToServices(app: dict):
    app['services'] = {}
    for container in app['containers']:
        app['services'][container['name']] = container
        del app['services'][container['name']]['name']
    del app['containers']
    return app


def validateEnvByValue(env: list, allowed: list, app_name: str):
    # Combine always_allowed_env with allowed into one list
    # Then check if all elements in env are in the resulting list
    all_allowed = allowed + always_allowed_env
    if(not checkArrayContainsAllElements(env, all_allowed)):
        # This has a weird syntax, and it confuses VSCode, but it works
        validation_regex = r"APP_{}(\S+)".format(
            app_name.upper().replace("-", "_"))
        for key in env:
            # If the key is neither in all_allowed nor is a full match against the validation regex, print a warning and return false
            if(key not in all_allowed and re.fullmatch(validation_regex, key) is None):
                print("Invalid environment variable {} in app {}".format(
                    key, app_name))
                return False
    return True


def validateEnv(app: dict, appName: str):
    # For every container of the app, check if all env vars in the strings in environment are defined in env
    for container in app['containers']:
        if 'environment' in container:
            if 'environment_allow' in container:
                existingEnv = list(container['environment_allow'].keys())
                del container['environment_allow']
            else:
                existingEnv = []
            # The next step depends on the type of the environment object, which is either a list or dict
            # If it's a list, split every string in it by the first=, then run getEnvVars(envVarValue) on it
            # ON a dict, run getEnvVars(envVarValue) on every value of the environment object
            # Then check if all env vars returned by getEnvVars are defined in env
            if(isinstance(container['environment'], list)):
                for envVar in container['environment']:
                    if(not validateEnvByValue(getEnvVars(envVar), existingEnv, appName)):
                        raise Exception(
                            "Env vars not defined for container " + container['name'])
            elif(isinstance(container['environment'], dict)):
                for envVar in container['environment'].values():
                    if(not validateEnvByValue(getEnvVars(envVar), existingEnv, appName)):
                        raise Exception(
                            "Env vars not defined for container " + container['name'])

    return app

# Converts the data of every container in app['containers'] to a volume, which is then added to the app


def convertDataDirToVolume(app: dict):
    for container in app['containers']:
        # Loop through data dirs in container['data'], if they don't contain a .., add them to container['volumes']
        # Also, a datadir shouldn't start with a /
        if 'data' in container:
            for dataDir in container['data']:
                if not 'volumes' in container:
                    container['volumes'] = []
                if(dataDir.find("..") == -1 and dataDir[0] != "/"):
                    container['volumes'].append(
                        '${APP_DATA_DIR}/' + dataDir)
                else:
                    print("Data dir " + dataDir +
                          " contains invalid characters")
            del container['data']
    return app


def convertIpToNetwork(app: dict, app_name: str, usedIpFile: str, envFile: str):
    for container in app['containers']:
        if 'ip' in container:
            container['networks'] = {'default': {
                'ipv4_address': container['ip']}}
            del container['ip']
        elif 'assignip' in container:
            if(container['assignip'] == 'False'): return app
            # Strip leading/trailing whitespace from container['name']
            container['name'] = container['name'].strip()
            # If the name still contains a newline, throw an error
            if(container['name'].find("\n") != -1):
                raise Exception("Newline in container name")
            env_var = "APP_{}_{}_IP".format(
                app_name.upper().replace("-", "_"),
                container['name'].upper().replace("-", "_")
                )
            # Write a list of used IPs to the usedIpFile as JSON, and read that file to check if an IP
            # can be used
            usedIps = []
            if(os.path.isfile(usedIpFile)):
                with open(usedIpFile, 'r') as f:
                    usedIps = json.load(f)
            # An IP 10.21.21.xx, with x being a random number above 50 is asigned to the container
            # If the IP is already in use, it will be tried again until it's not in use
            # If it's not in use, it will be added to the usedIps list and written to the usedIpFile
            # If the usedIpsFile contains all IPs between  10.21.21.50 and  10.21.21.255 (inclusive),
            # Throw an error, because no more IPs can be used
            if(len(usedIps) == 206):
                raise Exception("No more IPs can be used")

            while True:
                ip = "10.21.21." + str(random.randint(50, 255))
                if(ip not in usedIps):
                    usedIps.append(ip)
                    break
            container['networks'] = {'default': {
                'ipv4_address': "$" + env_var}}
            # Now append a new line  with APP_{app_name}_{container_name}_IP=${IP} to the envFile
            with open(envFile, 'a') as f:
                f.write("{}={}\n".format(env_var, ip))
            with open(usedIpFile, 'w') as f:
                json.dump(usedIps, f)
            del container['assignip']

    return app


def convertToDockerComposeYML(app: dict, usedIpFile: str, envFile: str):
    # The compose file doesn't care about metadata, but we need the name later.
    appName = app['metadata']['id']
    del app['metadata']
    app = convertContainerPermissions(app)
    app = validateEnv(app, appName)
    app = convertDataDirToVolume(app)
    app = convertIpToNetwork(app, appName, usedIpFile, envFile)
    app = convertContainersToServices(app)
    # Set version to 3.7 (current compose file version)
    app = {'version': '3.7', **app}
    return app
