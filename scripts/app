#!/usr/bin/env bash

# SPDX-FileCopyrightText: 2020-2021 Umbrel. https://getumbrel.com
#
# SPDX-License-Identifier: PolyForm-Noncommercial-1.0.0

set -euo pipefail

UMBREL_ROOT="$(readlink -f $(dirname "${BASH_SOURCE[0]}")/..)"
USER_FILE="${UMBREL_ROOT}/db/user.json"

check_dependencies () {
  for cmd in "$@"; do
    if ! command -v $cmd >/dev/null 2>&1; then
      echo "This script requires \"${cmd}\" to be installed"
      exit 1
    fi
  done
}

# Deterministically derives 128 bits of cryptographically secure entropy
derive_entropy () {
  # Make sure we use the seed from the real installation if this is
  # an OTA update.
  SEED_FILE="${UMBREL_ROOT}/db/umbrel-seed/seed"
  if [[ ! -f "${SEED_FILE}" ]] && [[ -f "${UMBREL_ROOT}/../.umbrel" ]]; then
    SEED_FILE="${UMBREL_ROOT}/../db/umbrel-seed/seed"
  fi

  identifier="${1}"
  umbrel_seed=$(cat "${SEED_FILE}") || true

  if [[ -z "$umbrel_seed" ]] || [[ -z "$identifier" ]]; then
    >&2 echo "Missing derivation parameter, this is unsafe, exiting."
    exit 1
  fi

  # We output as binary, then convert to he so we don't have to deal with openssl adding a prefix, and remove newlines openSSL adds after a character limit
  echo $(printf "%s" "${identifier}" | openssl dgst -sha256 -binary -hmac "${umbrel-seed}" | xxd -p | tr --delete "\n")
}

# Check dependencies
check_dependencies docker jq openssl

if [ -z ${1+x} ]; then
  command=""
else
  command="$1"
fi

if [ -z ${2+x} ]; then
  exit 1
else
  app="$2"
  app_dir="${UMBREL_ROOT}/apps/${app}"
  app_data_dir="${UMBREL_ROOT}/app-data/${app}"
  if [[ -z "${app}" ]] || [[ ! -d "${app_dir}" ]]; then
    echo "Error: \"${app}\" is not a valid app"
    exit 1
  fi
fi

if [ -z ${3+x} ]; then
  args=""
else
  args="${@:3}"
fi

compose() {
  local app="${1}"
  shift
  local env_file="${UMBREL_ROOT}/.env"
  local app_base_compose_file="${UMBREL_ROOT}/apps/docker-compose.common.yml"
  local app_compose_file="${app_dir}/docker-compose.yml"
  local app_domain="$(hostname -s 2>/dev/null || echo "umbrel").local"
  local app_hidden_servive_file="${UMBREL_ROOT}/tor/data/app-${app}/hostname"
  local app_entropy_identifier="app-${app}-seed"

  export BITCOIN_DATA_DIR="${UMBREL_ROOT}/bitcoin"
  export LND_DATA_DIR="${UMBREL_ROOT}/lnd"
  export APP_DATA_DIR="${app_data_dir}"
  export APP_DOMAIN="${app_domain}"
  export APP_HIDDEN_SERVICE="$(cat "${app_hidden_servive_file}" 2>/dev/null || echo "notyetset.onion")"
  export APP_SEED=$(derive_entropy "${app_entropy_identifier}")

  # App specific env vars
  # Note: Hardcoding app specific env vars is a short term solution. Long term
  # these values will be registered in an apps manifest and generated dynamically.
  local dojo_hidden_service_file="${UMBREL_ROOT}/tor/data/app-${app}-dojo/hostname"
  local whirlpool_hidden_service_file="${UMBREL_ROOT}/tor/data/app-${app}-whirlpool/hostname"
  local squeaknode_p2p_hidden_service_file="${UMBREL_ROOT}/tor/data/app-${app}-p2p/hostname"
  export APP_SAMOURAI_SERVER_DOJO_HIDDEN_SERVICE="$(cat "${dojo_hidden_service_file}" 2>/dev/null || echo "notyetset.onion")"
  export APP_SAMOURAI_SERVER_WHIRLPOOL_HIDDEN_SERVICE="$(cat "${whirlpool_hidden_service_file}" 2>/dev/null || echo "notyetset.onion")"
  export APP_SAMOURAI_SERVER_NODE_API_KEY=$(derive_entropy "env-${app_entropy_identifier}-NODE_API_KEY")
  export APP_SAMOURAI_SERVER_NODE_ADMIN_KEY=$(derive_entropy "env-${app_entropy_identifier}-NODE_ADMIN_KEY")
  export APP_SAMOURAI_SERVER_NODE_JWT_SECRET=$(derive_entropy "env-${app_entropy_identifier}-NODE_JWT_SECRET")
  export APP_SAMOURAI_SERVER_WHIRLPOOL_API_KEY=$(derive_entropy "env-${app_entropy_identifier}-WHIRLPOOL_API_KEY")
  export APP_SQUEAKNODE_P2P_HIDDEN_SERVICE="$(cat "${squeaknode_p2p_hidden_service_file}" 2>/dev/null || echo "notyetset.onion")"

  docker compose \
    --env-file "${env_file}" \
    --project-name "${app}" \
    --file "${app_base_compose_file}" \
    --file "${app_compose_file}" \
    "${@}"
}

# Pulls down images for an app and starts it
if [[ "$command" = "install" ]]; then

  echo "Setting up data dir for app ${app}..."
  mkdir -p "${app_data_dir}"
  rsync --archive --verbose --exclude ".gitkeep" "${app_dir}/." "${app_data_dir}"

  echo "Pulling images for app ${app}..."
  compose "${app}" pull

  echo "Starting app ${app}..."
  compose "${app}" up --detach

  echo "Successfully installed app ${app}"
  exit
fi

# Passes all arguments to docker compose
if [[ "$command" = "compose" ]]; then
  compose "${app}" ${args}

  exit
fi

# If we get here it means no valid command was supplied
exit 1
